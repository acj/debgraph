H A C K I N G
=============
The basic graph definition is in entity, node, edge and graph. Entity is the
base class for nodes and edges, with common functionality. Both have name-value
pairs with custom properties, and a "type". The Type defines whether the
node/edge is a binary package, a release or e.g. a dependency. Nodes also have
an optional id that can be used to look them up directly. To make them more
unique, they are prefixed with the node type, e.g. "Release:unstable". One
interesting and bizarre thing to note is the string cache: entities very often
have the same names and/or values in properties, so we just keep a reference to
them if they are used multiple times, this saves memory. Some overly verbose
properties are also filtered out during graph building.

Debian.* contains a debian-specific graph, that can read packages (and other
files) and populate the graph with the data in it. This also needs parser.* and
vercmp.*.

testkit is a generic factory-like thing that makes it easy to plug in "tests".
Just have a look at nulltest to see how it works. all new test should be done
this way.

nulltest and structure are existing "tests", structure being the only usefull
one. it does generate a graph of the connections between different types. This
is to the actual graph what a class diagram is to an object structure.

graphwalker is an early attempt to write a simple state-machine operator that 
can be used to find specific nodes. This should be removed, as well as the
dfs/low/mark things in node (which were used to find cycles in another version
of the code).

General Plan
------------
The idea is to define a set of operators that can be used to work on the graph.
They would return sets of nodes (perhaps sometimes sets of sets? think
cycles...), and be able to be used together. For performance reasons it would be
cool if these could work like iterators, and not first create all the sets in
memory.
Examples:
- find node by id
- all nodes
- filter by type or property
- state machine like operators (e.g. follow edges of type X and terminate on
  nodes of type Y)
- union, intersect, complement
- ...

Then sketch up a simple language that makes using these operators easier

S U M M E R   O F   C O D E
===========================
Student: Adam Jensen <acj@cse.msu.edu>
Mentor: Robert Lemmen <robertle@semistable.com>

This is basically the TODO list for the SOC work. As always, items to be
completed are marked with an "+", done items are "-". This list is subject to
change during the work.

- checkout the code and make sure it builds and runs on your machine. set up a
  comfortable working environment
- take this list, identify dependencies between items and reorder to your
  liking. please note that it might be a good idea to have a deep pipeline as
  you might need to wait on people every now and then. larger items or sets of
  smaller ones should have a time budget associated
+ find potential problems that we need to write tests for: read through policy,
  check other tools and talk to people who might have ideas
	+ Verify that nothing depends on Essential packages
	+ Look for loops among Essential packages (from vorlon on NMTask list)
	+ Verify that a runtime library's version matches the version of its
	  corresponding -dev package
+ talk to people about debgraph, they might have input. this is also important
  because we need to "sell" this a little bit
	* Completed by 10 June
	+ Bill Allombert would like to be able to check upgrade paths
		* Generate a set of packages that can be installed together
		  (without conflicting dependencies)
		* Formally:
			Given a family of sets Etch=S_1 U S_2 U S_3 U ... S_n
			Card(S_i)=1000
			n is not too far from Card(Etch)/1000
		* Then install each set S_i (with dependencies) and upgrade it
		  to Lenny
+ based on these findings, define the set of operators, their interface and what
  types of things they return. talk over with mentor.  make a decision
  on the set of operators to implement by 15 June.
	+ Define generic interface
	* Possible operators
		(Essential)
		+ Count nodes in a graph
		- Compute intersection of two sets of nodes 
		- Compute union of two sets of nodes
		+ Compute xor of two sets of nodes
		+ Compute difference of two sets of nodes
		+ Find/filter nodes based on property values (already implemented?)
		(Useful)
		+ State machine to track traversal info (cf. next two items)
		+ Recursively find nodes' dependencies
		+ Recursively find nodes' dependents (traverse edges in reverse)
		+ Merge subgraphs (or maybe merge sets of nodes into a single node 
		  in order to simulate a virtual package?)
		+ Invert node selection (complement)
		+ Find cycles (e.g., recursive depends/conflicts)
		(Exotic)
		+ TBD
+ implement them. this is a "milestone delivery", to be completed by 10
  July
+ perhaps one or more operators will be quite complicated and require a small
  parser (e.g. something like a state machine), so be prepared for the work
+ sketch up a language that can be used to query the graph. talk over with
  mentor
	+ Support for universal/existential quantifiers (e.g., for all
	  packages that conflict, perform action X) 
+ implement it. "milestone delivery"
+ small pdf text or presentation that explains debgraph to a potential user (who
  might need convincing)
+ write test suite for operators and query language with reasonable code 
  coverage
+ write user and developer documentation for the graph operators,
  language, etc.  to be completed by 11 August
